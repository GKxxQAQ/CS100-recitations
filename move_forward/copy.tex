
\section{Copy is Not Welcome!}

\begin{frame}[fragile]{How many copies?}
  \begin{cpp}
std::string foo() {
  std::string s = some_value();
  return s;
}
std::string t = foo();
  \end{cpp}
  \pause
  \begin{enumerate}
    \item Before C++11, the local variable \boxilcpp{s} is returned by a \textbf{copy-initialization} of a temporary object,
    \item which is then used to \textbf{copy-initialize} \boxilcpp{t}.
    \pause
  \end{enumerate}
  Compilers are allowed to perform \textbf{Return-value optimization} (RVO) or \textbf{Named Return-value Optimization} (NRVO) which eliminate copies in some cases.
\end{frame}

\begin{frame}[fragile]{How copy affects efficiency}
  \begin{cpp}
char some_char(int);

std::string fun1(int n) {
  std::string s = "";
  for (auto i = 0; i != n; ++i)
@\pinkbox @    s += some_char(i);
  return s;
}

std::string fun2(int n) {
  std::string s = "";
  for (auto i = 0; i != n; ++i)
@\pinkbox @    s = s + some_char(i);
  return s;
}
  \end{cpp}
\end{frame}

\begin{frame}[fragile]{How copy affects efficiency}
  \begin{cpp}
for (auto i = 0; i != n; ++i)
  s += some_char(i);
for (auto i = 0; i != n; ++i)
  s = s + some_char(i);
  \end{cpp}
  \begin{itemize}
    \item \ilcpp{s += some_char(i)} is virtually the same as \ilcpp{s.push_back(i)}, which consumes little time.
    \item \ilcpp{s = s + some_char(i)} causes \textbf{two copies}: a temporary object generated by \ilcpp{s + some_char(i)}, and a \textbf{copy-assignment} to \boxilcpp{s}.
  \end{itemize}
  \pause
  As a result, the first code takes \(O(n)\) time, while the second one takes \(O\left(n^2\right)\) time (assuming \ilcpp{some_char(i)} is \(O(1)\)).
\end{frame}

\begin{frame}[fragile]{Why is copy needed?}
  \begin{cpp}
a = b;
  \end{cpp}
  \begin{itemize}
    \item We may want \boxilcpp{a} and \boxilcpp{b} to be different and independent objects.
    \item We may want to make changes to \boxilcpp{a} without affecting \boxilcpp{b}.
  \end{itemize}
  \pause
  However, sometimes the ``\textbf{copied-from} object'' is about to die.
  \begin{cpp}
a = c + d;
  \end{cpp}
  \begin{itemize}
    \item Can we just let \boxilcpp{a} take the ownership of \boxilcpp{b}'s resources?
  \end{itemize}
\end{frame}